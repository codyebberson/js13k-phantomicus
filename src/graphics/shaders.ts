// Autogenerated by shadermin.js
// Do not modify manually

export const ATTRIBUTE_COLOR = 'a';
export const ATTRIBUTE_NORMAL = 'b';
export const ATTRIBUTE_POSITION = 'c';
export const ATTRIBUTE_TEXCOORD = 'd';
export const ATTRIBUTE_WORLDMATRIX = 'e';
export const UNIFORM_AMBIENTLIGHT = 'g';
export const UNIFORM_BLOOMTEXTURE = 'h';
export const UNIFORM_CAMERAPOSITION = 'i';
export const UNIFORM_COLORTEXTURE = 'j';
export const UNIFORM_DEPTHTEXTURE = 'k';
export const UNIFORM_ITERATION = 'l';
export const UNIFORM_LIGHTDIRECTION = 'm';
export const UNIFORM_LIGHTPOSITION = 'n';
export const UNIFORM_PROJECTIONMATRIX = 'o';
export const UNIFORM_SHADOWMAPMATRIX = 'p';
export const UNIFORM_VIEWMATRIX = 'q';

const GLSL_PREFIX =
  '#version 300 es\n' +
  'precision mediump float;';

export const BLOOM_FRAG =
  GLSL_PREFIX +
  'uniform sampler2D j;' +
  'uniform int l;' +
  'in vec2 v;' +
  'out vec4 f;' +
  'float z[11]=float[11](0.01f,0.02f,0.04f,0.08f,0.16f,0.38f,0.16f,0.08f,0.04f,0.02f,0.01f);' +
  'void main(){' +
  'if(l==0){' +
  'vec4 w=texture(j,v);' +
  'if(max(w.r,max(w.g,w.b))>(0.99f)){' +
  'f=w;' +
  '}' +
  'else{' +
  'discard;' +
  '}' +
  '}' +
  'else{' +
  'vec4 x=vec4(0);' +
  'float y=0.0f;' +
  'for(int A=-5;' +
  'A<=5;' +
  'A++){' +
  'vec4 w=texture(j,v+(l%2==1?vec2(float(A)/512.0f,0.0f):vec2(0.0f,float(A)/512.0f)));' +
  'x.rgb+=z[A+5]*w.rgb*w.a;' +
  'y+=z[A+5]*w.a;' +
  '}' +
  'f=y==0.0f?vec4(0,0,0,1):vec4(x.rgb/y,y);' +
  '}' +
  '}';

export const BLOOM_VERT =
  GLSL_PREFIX +
  'in vec2 c,d;' +
  'out vec2 v;' +
  'void main(){' +
  'gl_Position=vec4(c,0,1);' +
  'v=d;' +
  '}';

export const MAIN_FRAG =
  GLSL_PREFIX +
  'uniform vec3 i,n,m;' +
  'uniform sampler2D k;' +
  'uniform float g;' +
  'in vec4 r,t,s,u;' +
  'out vec4 f;' +
  'void main(){' +
  'if(r.r>0.99f||r.g>0.99f||r.b>0.99f){' +
  'f=r;' +
  'return;' +
  '}' +
  'vec3 G=normalize(s.xyz),B=u.xyz/u.w;' +
  'float A=0.0f,w=0.0f;' +
  'for(int D=-2;' +
  'D<=2;' +
  'D++){' +
  'for(int C=-2;' +
  'C<=2;' +
  'C++){' +
  'if(((texture(k,B.xy+vec2(C,D)/1024.0f)).r)<=(B.z-(0.0001f))){' +
  'w+=1.0f;' +
  '}' +
  'A+=1.0f;' +
  '}' +
  '}' +
  'vec3 z=t.xyz-n,y=normalize(t.xyz-n);' +
  'float x=dot(z,z),E=0.0f;' +
  'if((B.x>=0.0f&&B.x<=1.0f&&B.y>=0.0f&&B.y<=1.0f)&&(x<1600.0f&&(dot(y,normalize(m)))>0.9f)){' +
  'E=(1.0f-w/A)*(1.0f/(1.0f+0.001f*(sqrt(x))+0.0003f*x));' +
  '}' +
  'vec3 F=mix(vec3(0.0f,0.0f,0.0f),(r.rgb),(clamp(g*(max(0.0f,dot((normalize(t.xyz-(vec3(256.0f,256.0f,-128.0f)))),G)))+(1.2f-g)*(max(0.0f,dot(y,G)))*E,0.0f,1.0f)));' +
  'F=mix(F,vec3(1.0f,1.0f,1.0f),(E*pow(max(dot((normalize(i-t.xyz)),(reflect(y,G))),0.0f),(64.0f))));' +
  'f=vec4(F.rgb,r.a);' +
  '}';

export const MAIN_VERT =
  GLSL_PREFIX +
  'in vec4 c,a,b;' +
  'in mat4 e;' +
  'uniform mat4 o,q,p;' +
  'out vec4 t,s,r,u;' +
  'void main(){' +
  't=e*c;' +
  's=transpose(inverse(e))*b*-1.0f;' +
  'r=a;' +
  'u=p*t;' +
  'gl_Position=o*q*t;' +
  '}';

export const POST_FRAG =
  GLSL_PREFIX +
  'uniform sampler2D j,h;' +
  'in vec2 v;' +
  'out vec4 f;' +
  'void main(){' +
  'vec4 w=texture(h,v);' +
  'f=vec4((texture(j,v)).rgb+2.0f*w.a*w.rgb,1);' +
  '}';

export const POST_VERT =
  GLSL_PREFIX +
  'in vec2 c,d;' +
  'out vec2 v;' +
  'void main(){' +
  'gl_Position=vec4(c,0,1);' +
  'v=d;' +
  '}';

export const SHADOW_FRAG =
  GLSL_PREFIX +
  'out vec4 f;' +
  'void main(){' +
  'f=vec4(1);' +
  '}';

export const SHADOW_VERT =
  GLSL_PREFIX +
  'in vec4 c;' +
  'layout(location=3)in mat4 e;' +
  'uniform mat4 o,q;' +
  'void main(){' +
  'gl_Position=o*q*e*c;' +
  '}';
